from flask import Flask, request, jsonify
import time
import threading
import os # For environment variables
import ssl # For HTTPS

app = Flask(__name__)

# --- Global Variables ---
registered_pis = {}
LOCK = threading.Lock()
TIMEOUT_SECONDS = 600 # 10 minutes

# Load the expected API key from the environment variable set in docker-compose
EXPECTED_REGISTRATION_API_KEY = os.environ.get("PI_REGISTER_API_KEY")
if not EXPECTED_REGISTRATION_API_KEY:
    app.logger.error("CRITICAL: PI_REGISTER_API_KEY environment variable is not set!")
    # Consider exiting if the key is mandatory for the app to function
    # For now, it will allow requests but they will fail auth if key is checked

# --- API Routes ---
@app.route('/register', methods=['POST'])
def register_pi():
    # Validate API Key
    if not EXPECTED_REGISTRATION_API_KEY: # Should have been caught at startup
        app.logger.error("Server misconfiguration: API key not loaded.")
        return jsonify({"status": "error", "message": "Server configuration error"}), 500

    received_key = request.headers.get("X-Pi-Register-Api-Key")
    if received_key != EXPECTED_REGISTRATION_API_KEY:
        app.logger.warning(f"Unauthorized /register attempt. Incorrect or missing API key. Received: '{received_key}'")
        return jsonify({"status": "error", "message": "Unauthorized - Invalid API Key"}), 401

    # If key is valid, proceed with registration
    data = request.get_json()
    identifier = data.get('identifier')
    ip = data.get('ip')
    port = data.get('port', 8000) # Default exporter port

    if not identifier or not ip:
        return jsonify({"status": "error", "message": "Missing identifier or ip"}), 400

    with LOCK:
        registered_pis[identifier] = {
            "ip": ip,
            "port": port,
            "timestamp": time.time()
        }
    app.logger.info(f"Registered/Updated Pi: {identifier} at {ip}:{port}")
    return jsonify({"status": "success"}), 200

@app.route('/targets')
def get_targets():
    targets_list = []
    current_time = time.time()
    active_pis_for_response = {} # Temporary dict for logging

    with LOCK:
        # Filter out stale entries and prepare for Prometheus
        active_pis = {
            id: info for id, info in registered_pis.items()
            if current_time - info['timestamp'] < TIMEOUT_SECONDS
        }
        # Optional: If you want to actively prune the main registered_pis dict
        # global registered_pis
        # registered_pis = active_pis.copy()


        for identifier, info in active_pis.items():
            targets_list.append({
                "targets": [f"{info['ip']}:{info['port']}"],
                "labels": {
                    "pi_identifier": identifier,
                    "job": "pi_network_monitor_http_sd"
                }
            })
            active_pis_for_response[identifier] = f"{info['ip']}:{info['port']}"

    # app.logger.debug(f"Returning targets ({len(targets_list)} active): {active_pis_for_response}")
    return jsonify(targets_list)

if __name__ == '__main__':
    # Define the SSL context for HTTPS
    # These paths are *inside* the Docker container, where certs are mounted via docker-compose.yml
    cert_path = '/certs/cert.pem'
    key_path = '/certs/key.pem'
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)

    try:
        context.load_cert_chain(cert_path, key_path)
        app.logger.info(f"Attempting to start Flask server with HTTPS on 0.0.0.0:5000")
        app.logger.info(f"Using cert: {cert_path}, key: {key_path}")
        # Set Flask's built-in reloader to False if you have issues with it in SSL context
        # or when running with multiple workers (though typically not an issue for this app).
        app.run(host='0.0.0.0', port=5000, ssl_context=context, use_reloader=False)
    except FileNotFoundError:
        app.logger.error(f"FATAL: SSL certificate or key file not found. Searched for:")
        app.logger.error(f"  Certificate: {cert_path}")
        app.logger.error(f"  Key: {key_path}")
        app.logger.error("Ensure certificates are correctly generated by setup_server.sh and mounted in docker-compose.yml.")
        app.logger.error("HTTPS will not be enabled. Exiting.")
        exit(1) # Exit if SSL cannot be configured
    except Exception as e:
        app.logger.error(f"An error occurred while setting up SSL or starting the server: {e}")
        exit(1)
